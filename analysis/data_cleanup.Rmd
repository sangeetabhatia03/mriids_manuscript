---
output: 
  pdf_document:
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
title: Cleaning up the feed from HealthMap/ProMED
author:
- name: Sangeeta Bhatia
  affiliation: Imperial College London
abstract: 
keywords: 
date: "`r Sys.Date()`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
# spacing: double
bibliography: 
biblio-style: apsr
endnote: no
params:
  infile: data/raw/promed_2014-2016-renamed.csv
  outfile: promed_loglinear
  ofinterest: data/processed/all_african_centroids.csv
---


```{r data-cleanup-1, include=FALSE}
knitr::opts_chunk$set(fig.width = 12, fig.height = 6, echo = FALSE,
                      warning = FALSE, message = FALSE,
                      fig.path = "figures/")

```


```{r setup}
library(ggplot2)
library(ggthemes)
library(scales)
library(dplyr)
library(mRIIDS)
```


```{r ds1_params}

species   <- "Humans"
disease   <- "Ebola"
case.type <- "scc"
wafrica <- c("Sierra Leone",
             "Liberia",
             "Guinea")
             ## "Senegal",
             ## "Ghana",
             ## "Mali",
             ## "Nigeria")
```



Visualising the raw data.



```{r}

feed <- here::here(params$infile) %>%
             read.csv(stringsAsFactors = FALSE) %>%
    filter(Species == species &
           Disease == disease &
           Country %in% wafrica)

feed <- janitor::clean_names(feed)

```

Strip the date of the time stamp
```{r}
feed <- tidyr::separate(feed,
                        issue_date,
                        sep = " ",
                        into = c("issue_date", "time"),
                        remove = TRUE
                        )
```



Split the data by country.

```{r split}
by.location <- feed %>%
    split(.$country) 

```

### Raw data by case category

```{r rawviz}
raw_p <- purrr::map(by.location, function(x) {
    x <- select(x, issue_date, sc, sd, cc, cd, country) %>%
        tidyr::gather(case_type,
                      count, -c(issue_date, country)) 
    x$issue_date <- as.Date(x$issue_date,
                            format = "%m/%d/%y")
    p <- ggplot(x ,
                aes(issue_date, count, col = case_type)) +
        geom_point()
    p <- p + theme_classic()
    p <- p + xlab("") + ylab("Cases")
    p <- p + theme(panel.border=element_blank(), axis.line = element_line())
    p <- p + theme(axis.text.x = element_text(angle = 80, hjust = 1))
    p <- p + theme(legend.title = element_blank())
    p <- p + xlab("")
    p <- p + scale_x_date(date_labels =  "%b %Y")
    p <- p + ggtitle(x$country[1])
    p <- p + scale_color_discrete(
                         breaks = c("sc", "sd", "cc", "cd"),
                         labels = c("SC", "SD", "CC", "CD"))
    p
})

```

## 

```{r hmraw}
ggpubr::ggarrange(plotlist = raw_p, common.legend = TRUE) %>%
    ggpubr::ggexport(filename = here::here("data/output/figures",
                                           paste0(params$outfile,
                                                  "_raw.png")),
                     res = 144,
                     width = 960,
                     height = 540)
```
# Data clean-up

Extract the total case count as a sum of suspected and
confirmed cases.


```{r cumcases}

cum_cases <- purrr::map(by.location, function(df) {
    mRIIDS:::update_cases_column(df, case.type) 
})
    
```

## Merge duplicate alerts

```{r cols}
cols.to.keep <- c("location", "country", "disease", "species",
                  "healthmap_alert_id", "headline", "url",
                  "alert_tag", "feed_name", "lon", "lat")
## These are columns we generate ourselves later on
cols.to.keep <- c(cols.to.keep, "date", "cases") 
```

```{r nodups}
no_dups <- purrr::map(cum_cases, function(df) {
    mRIIDS:::merge_duplicates(df, cols.to.keep)
})    
```

## Remove outliers. 

```{r noout}
use_last   <- 20
p.within.k <- 0.50
k_sd       <- mRIIDS:::interval_width_for_p(use_last,
                                            1 - p.within.k) %>%
    sqrt %>%
    `[`(2)

no_outliers <- purrr::map(no_dups, function(df) {
    df <- arrange(df, date)
    df <- filter(df, !is.na(cases)) %>% select(date, cases)
    if (nrow(df) == 0) {
        return(NULL)
    } else {
        df <- mRIIDS:::remove_last_outliers(df,
                                            use_last = use_last,
                                            k_sd = k_sd)
    }     
    message(df$country[1])
    df
})    

```

## Make monotonically increasing.
```{r inc}

mono_inc <- purrr::map(no_outliers,
                       ~ mRIIDS:::make_monotonically_increasing(.x))

```

## Interpolate missing data
Finally, interpolate missing data.

```{r interp}
interpolated <- purrr::map(mono_inc,
                           ~ mRIIDS:::interpolate_missing_data(.x,
                                                               method = "linear"))
    
  
```

## Plot


##Â Total cases as sum of sc and cc.
Common plotting logic. x must have a date and a cases column.

```{r}
cases_ts <- function(x) {
    p <- ggplot(x, aes(date, cases)) + geom_point()
    p <- p + theme_classic() 
    p <- p + xlab("") + ylab("Cases")
    p <- p + theme(axis.text.x = element_text(angle = 80, hjust = 1))
    p <- p + xlab("")
    p <- p + scale_x_date(date_labels =  "%b %Y")
    p     
}

```

```{r viz1}
total_p <- purrr::map(cum_cases, cases_ts)
```

## Remove duplicate alerts

```{r viz2}
nodups_p <- purrr::map(no_dups, cases_ts) 
```

## Remove outliers 

```{r viz3}
nooutss_p <- purrr::map(no_outliers, cases_ts)
```

## Make increasing

```{r viz4}
monoinc_p <- purrr::map(mono_inc, cases_ts)
```

## Interpolated data

This needs a slightly different viz.

```{r vizinterp, eval = TRUE}
interp_p <- purrr::map(interpolated, function(x) {
    x$src <- "Raw"
    idx <- which(is.na(x$cases))
    x$src[idx] <- "Interpolated"
    x <- select(x,
                date = interpolated_date,
                cases = interpolated_cases,
                src)
    p <- ggplot(x, aes(date, cases, col = src)) + geom_point()
    p <- p + theme_classic() 
    p <- p + xlab("") + ylab("Cases")
    p <- p + theme(axis.text.x = element_text(angle = 80, hjust = 1))
    p <- p + theme(panel.border = element_blank(),
                   axis.line = element_line())
    p <- p + xlab("") + theme(legend.title = element_blank())
    p <- p + scale_x_date(date_labels =  "%b %Y")
    p     
})    
```

Putting them together.

```{r incid_tall, eval = TRUE}

countries <- names(by.location)
graphs <- list(raw_p,
               total_p,
               nodups_p,
               nooutss_p,
               monoinc_p,
               interp_p)
purrr::map(countries, function(c){
    cspecific <- purrr::map(graphs, ~ .x[[c]])
    p <- ggpubr::ggarrange(plotlist = cspecific, nrow = 3, ncol = 2)
    ggpubr::ggexport(p,
                     filename = here::here("data/output/figures",
                                           paste0(params$outfile,
                                                 "_",
                                                 c,
                                                 ".png")),
                     res = 72,
                     width = 960,
                     height = 540)
})

```

## Derive incidence time series from interpolated cumulative cases

Stan is not going to like real numbers for a Poisson process.
So first we cast the cumulative case counts as integers and then 
take the difference.


```{r tall}
incid_tall <- purrr::map_dfr(interpolated, function(x) {
    x <- select(x,
                date = interpolated_date,
                cases = interpolated_cases)
    x$cases <- as.integer(x$cases)
    x$incid <- c(0, diff(x$cases))
    x <- select(x, date, incid)
    x
}, .id = "country")                 
```

And reshape

```{r wide}
incid_wide <- tidyr::spread(incid_tall, country, incid, fill = 0)
```

Replace country names with ISO3 codes for ease.

```{r iso3c}
colnames(incid_wide)[-1] <-
    countrycode::countrycode(colnames(incid_wide)[-1],
                             "country.name",
                             "iso3c")
```
## Add 0 incidence for other countries

Finally, we add 0 incidence for all countries other than ones for
which we already have data. 

```{r}
ofinterest <- readr::read_csv(here::here(params$ofinterest)) %>%
    filter(include == "TRUE")

nodata <- setdiff(ofinterest$ISO3,
                  countrycode::countrycode(wafrica,
                                           'country.name',
                                           'iso3c'))
df <- matrix(0,
             nrow = nrow(incid_wide),
             ncol = length(nodata))
colnames(df) <- nodata
df <- data.frame(df)
incid_wide_all <- cbind(incid_wide, df)
```

Finally ensure that the order of countries in centroids and incid 
files is the same.

```{r eval = TRUE}
inorder <- ofinterest$ISO3
incid_wide_all <- select(incid_wide_all,
                         date,
                         inorder)
```


## Write the output

```{r write}

outfile <- paste0(params$outfile, "_wide.csv")
here::here("data/processed", outfile) %>%
    readr::write_csv(x = incid_wide_all,
                     path = .)

```
 
